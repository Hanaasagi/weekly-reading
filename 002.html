<!DOCTYPE html>
<html lang="zh" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>002 - weekly reading</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="https://hanaasagi.github.io/weekly-reading/002.html">

        <meta name="author" content="Hanaasagi" />
        <meta name="description" content="作为一个码农，不能理解程序员口中的 微服务化是趋势 区块链开创未来 前后端分离是历史的选择 Microservices Martin Fowler 所写，此文有两个版本的中译。建议全文阅读。 Microservices: The Good, the Bad, and the Ugly 这篇文章被转的到处都是 The Good 能以高效的方式轻松扩展 不存在单点故障 在不影响整个应用程序完整性的情况下下线，重构或重写 针对不同服务的需求，选择最佳的语言和框架 简单且离散 轻松满足现代 PaaS 和 SaaS 环境的需求 对于第二条说的就跟 monolithic 应用存在单点故障一样，有没有单点和微服务好像没有什么关系吧 The Bad 由于需要维护基于微服务的应用及组件所需的专业知识，因此变得更复杂 如果应用不需要扩展或者不是 cloud-based，基于微服务的架构可能不会带来任何有意义的好处 No greenfield options because microservices …" />

        <meta property="og:site_name" content="weekly reading" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="002"/>
        <meta property="og:url" content="https://hanaasagi.github.io/weekly-reading/002.html"/>
        <meta property="og:description" content="作为一个码农，不能理解程序员口中的 微服务化是趋势 区块链开创未来 前后端分离是历史的选择 Microservices Martin Fowler 所写，此文有两个版本的中译。建议全文阅读。 Microservices: The Good, the Bad, and the Ugly 这篇文章被转的到处都是 The Good 能以高效的方式轻松扩展 不存在单点故障 在不影响整个应用程序完整性的情况下下线，重构或重写 针对不同服务的需求，选择最佳的语言和框架 简单且离散 轻松满足现代 PaaS 和 SaaS 环境的需求 对于第二条说的就跟 monolithic 应用存在单点故障一样，有没有单点和微服务好像没有什么关系吧 The Bad 由于需要维护基于微服务的应用及组件所需的专业知识，因此变得更复杂 如果应用不需要扩展或者不是 cloud-based，基于微服务的架构可能不会带来任何有意义的好处 No greenfield options because microservices …"/>
        <meta property="article:published_time" content="2018-05-12" />
            <meta property="article:section" content="misc" />
            <meta property="article:author" content="Hanaasagi" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://hanaasagi.github.io/weekly-reading/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="https://hanaasagi.github.io/weekly-reading/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://hanaasagi.github.io/weekly-reading/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="https://hanaasagi.github.io/weekly-reading/theme/css/style.css" type="text/css"/>





</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <a href="https://hanaasagi.github.io/weekly-reading/" class="navbar-brand">
weekly reading            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<!-- Banner -->
<!-- End Banner -->

<!-- Content Container -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="https://hanaasagi.github.io/weekly-reading/002.html"
                       rel="bookmark"
                       title="Permalink to 002">
                        002
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2018-05-12T00:00:00+08:00"> Sat 12 May 2018</time>
    </span>





    
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>作为一个码农，不能理解程序员口中的</p>
<ul>
<li>微服务化是趋势</li>
<li>区块链开创未来</li>
<li>前后端分离是历史的选择</li>
</ul>
<h3><a href="https://martinfowler.com/articles/microservices.html">Microservices</a></h3>
<p>Martin Fowler 所写，此文有两个版本的中译。建议全文阅读。</p>
<h3><a href="https://dzone.com/articles/microservices-the-good-the-bad-and-the-ugly">Microservices: The Good, the Bad, and the Ugly</a></h3>
<p>这篇文章被转的到处都是</p>
<h4>The Good</h4>
<ul>
<li>能以高效的方式轻松扩展</li>
<li>不存在单点故障</li>
<li>在不影响整个应用程序完整性的情况下下线，重构或重写</li>
<li>针对不同服务的需求，选择最佳的语言和框架</li>
<li>简单且离散</li>
<li>轻松满足现代 PaaS 和 SaaS 环境的需求</li>
</ul>
<p>对于第二条说的就跟 monolithic 应用存在单点故障一样，有没有单点和微服务好像没有什么关系吧</p>
<h4>The Bad</h4>
<ul>
<li>由于需要维护基于微服务的应用及组件所需的专业知识，因此变得更复杂</li>
<li>如果应用不需要扩展或者不是 cloud-based，基于微服务的架构可能不会带来任何有意义的好处</li>
<li>No greenfield options because microservices need to connect to existing (and possibly monolithic) systems</li>
<li>通过 API 进行通信需要更强大的测试方法以及整个团队的支持</li>
<li>需要增加团队管理和沟通，以确保每个人(而不仅仅是某些工程师)了解每个服务和整个系统。</li>
</ul>
<h4>The Ugly</h4>
<p>不要跟风。Netflix 及一些热门的硅谷新宠已经接受微服务并不意味着它是所有应用的正确架构风格。应用架构不仅应该基于当前流行的东西，还更应该基于实际功效和是否适用。</p>
<ul>
<li>分布式系统的开发、部署、运营管理需要比较高的启动资金</li>
<li>为不同的组件选择不同的技术栈会导致不统一的应用设计和体系架构</li>
<li>更新文档比较麻烦(如果用 ProtoBuf 的话，proto 文件可以充当接口文档)</li>
<li>维护成本，运营成本和生产监控成本要高得多，后者也缺乏可用的工具(可用的工具就现在来说已经很多了)</li>
<li>Increased resource and memory consumption from all the independently running components which need their own runtime containers with more memory and CPU</li>
<li>微服务如果实施不当，可能翻车</li>
</ul>
<p>作者鼓励理智思考，因为它是一把双刃剑</p>
<h3><a href="https://blog.rapid7.com/2016/09/15/microservices-please-dont/">Microservices – Please, don’t</a></h3>
<p>中文翻译 <a href="https://www.jianshu.com/p/491e494102f0?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">Microservices – Please, don’t</a></p>
<p>并非是真理，也可能是谬论</p>
<ul>
<li>It keeps the code cleaner</li>
</ul>
<p>它通过减少所涉及的部分来对你进行约束，这不是在解决最根本的问题。可以定义内部边界，而不一定要引入网络边界。</p>
<ul>
<li>It’s easy to write things that only have one purpose</li>
</ul>
<p>涉及多个远程服务会引入额外的复杂性。需要和其他部分进行协作来完成数据的变更，这会让你陷入分布式事务之中。</p>
<ul>
<li>They’re faster than monoliths</li>
</ul>
<p>将应用缩小，减少依赖本身便可以更快。引入了网络间调用，这肯定比 co-resident code calls 慢。对于一个新的项目来说，CPU 和 内存并不是瓶颈，反而网络 I/O 的影响更为突出</p>
<ul>
<li>It’s easy for engineers to not all work in the same codebase</li>
</ul>
<p>测试麻烦，需要部署所有依赖的服务才能运行。使用 Docker 可以解决部署环境问题。不同服务可能由不同团队进行维护，增加了解决 Bug 时的交流成本</p>
<ul>
<li>It’s the simplest way to handle autoscaling, plus Docker is in here somewhere</li>
</ul>
<p>将服务打包成离散的单元，然后通过 Docker 来横向伸缩是没有错的。但不能说这是微服务的专属手段，monolithic 应用也可以这样做。</p>
<p>作者给出的建议：</p>
<p>理解你的 domin，合理划分服务边界，理清依赖关系。这些是微服务化的前提。</p>
<h3><a href="http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html">Microservices - Not a free lunch!</a></h3>
<p>好处</p>
<ul>
<li>服务本身是简单的，侧重于做好一件事</li>
<li>可以使用最佳和最合适的工具来构建每个服务</li>
<li>松耦合</li>
<li>在这个模型下，多个开发人员和团队可以相互独立地交付</li>
<li>支持频繁地发布，同时保持系统的其余部分可用且稳定</li>
</ul>
<p>服务变得简单了，但是管理和发布这些服务变得复杂了。</p>
<h5>运维开销</h5>
<p>从单个 monolithic 应用转为 N 个服务的构建，测试，部署和运行。而且他们可能不是同一个技术栈。如果考虑故障转移和弹性伸缩的话，可能维护的数量会更多。Kubernetes 解决了这个问题，但是引入了 Kubernetes 的维护开销</p>
<h5>隐式接口</h5>
<p>将系统分解为互相协作的组件，便会引入接口这种概念。接口用作契约，双方需要交换相同的消息格式，并且对这些消息具有相同的语义理解，例如 ProtoBuf。更改契约某一侧的语法或语义，并且所有其他服务都需要了解该更改。在微服务环境中，这可能意味着简单的更改会导致对许多不同组件进行更改，然后以某种顺序将他们依次发布。</p>
<h5>重复努力</h5>
<p>作者举了一个例子</p>
<blockquote>
<p>Imagine that there is a new business requirement to calculate tax differently for a certain product line. We have a few choices in how to deliver this.
We could introduce a new service and allow the other services to call into this where needed. That does however introduce more potentially synchronous coupling into the system, so is not a decision we would take lightly.
We could duplicate the effort, adding the tax calculation into all of the services that need it. Besides the duplicated development effort, repeating ourselves in this way is generally considered a bad idea as every instance of the code will need to be tested and maintained going forward.
The final option is to share resources such as a tax calculating library between the services. This can be useful, but it won't always work in a polyglot environment and introduces coupling which may mean that services have to be released in parallel to maintain the implicit interface between them. This coupling essentially mitigates a lot of the benefits of Microservices approaches.
It seems to me that all three of these options are sub-optimal as opposed to writing the piece of code once and making it available throughout the monolithic application. The teams I have seen working in this style tend towards option 2, duplicating of business logic, which goes against many principles of good software engineering. And yes, this even takes place in well decomposed and designed systems - it's not always a sign of bad service boundaries.</p>
</blockquote>
<h5>分布式系统的复杂性</h5>
<p>微服务意味着分布式系统。先前我们可能使用方法调用来跨越系统的边界，而现在我们需要引入远程调用，来将不同服务器上不同进程的组件进行粘合。我们需要考虑一些以前未曾想过的问题，比如：网络延迟，容错，消息序列化，网络不可用，异步性，版本控制</p>
<h5>异步的困难</h5>
<p>以微服务风格构建的系统可能会比单一应用程序更加异步。当我们可以将工作分解成真正独立的独立任务时，异步系统是个好的主意。然而，当事件必须在异步架构中同步或事务性地发生时，将变得非常复杂。</p>
<h5>为测试带来新挑战</h5>
<blockquote>
<p>With so many services all evolving at different paces and different services rolling out canary releases internally, it can be difficult to recreate environments in a consistent way for either manual or automated testing. When we add in asynchronicity and dynamic message loads, it becomes much harder to test systems built in this style and gain confidence in the set of services that we are about to release into production. We can test the individual service, but in this dynamic environment, very subtle behaviours can emerge from the interactions of the services which are hard to visualise and speculate on, let alone comprehensively test for.</p>
</blockquote>
            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>
<!-- Sidebar -->
<section class="well well-sm">
  <ul class="list-group list-group-flush">

<!-- Sidebar/Links -->
<li class="list-group-item">
  <h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
  <ul class="list-group" id="links">
    <li class="list-group-item">
      <a href="https://blog.dreamfever.me" target="_blank">Blog</a>
    </li>
    <li class="list-group-item">
      <a href="https://github.com/Hanaasagi" target="_blank">GitHub</a>
    </li>
  </ul>
</li>
<!-- End Sidebar/Links -->
  </ul>
</section>
<!-- End Sidebar -->            </aside>
        </div>
    </div>
</div>
<!-- End Content Container -->

<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 Hanaasagi
            &middot; Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://hanaasagi.github.io/weekly-reading/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://hanaasagi.github.io/weekly-reading/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="https://hanaasagi.github.io/weekly-reading/theme/js/respond.min.js"></script>




</body>
</html>